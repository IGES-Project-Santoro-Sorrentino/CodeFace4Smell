#!/usr/bin/env bash
set -euo pipefail

# ============================
# generate_conf_from_repo.sh
# ============================
# Uso:
#   ./generate_conf_from_repo.sh git-repos/<repo>
#
# Cosa fa:
#  - Estrae i tag della repo e separa release "stable" da RC
#  - Genera conf/<project>.conf con:
#       project, repo, description, revisions, rcs, tagging, sloccount
#  - Le liste revisions/rcs hanno stessa lunghezza
#  - Le RC sono abbinate per nome/versione; in fallback per data
#  - Se non c’è RC per una release, inserisce "" in rcs
#
# Nota:
#  - “project” = nome cartella repo (si può cambiare a piacere)
#  - “repo” = nome cartella repo (matcha quello passato poi a codeface)

REPO_PATH="${1:-}"
if [[ -z "${REPO_PATH}" ]]; then
  echo "Uso: $0 <path_repo_locale>" >&2
  exit 1
fi
if [[ ! -d "${REPO_PATH}/.git" ]]; then
  echo "Errore: ${REPO_PATH} non sembra una repo git (manca .git)" >&2
  exit 1
fi

mkdir -p conf

REPO_NAME="$(basename "${REPO_PATH}")"
PROJECT_NAME="${REPO_NAME}"
DESCRIPTION="Auto-generated config for ${PROJECT_NAME}"

# Quanti rilasci considerare (ultimi N per data)
: "${N_RELEASES:=20}"

# --- Estrai tag + date (ordinati per data del tag) ---
# formato: name|date
mapfile -t ALL_TAGS_LINES < <(
  git -C "${REPO_PATH}" for-each-ref \
    --sort=taggerdate --format='%(refname:short)|%(taggerdate:iso8601)' refs/tags || true
)

# Se non ci sono tag, fallback a primo/ultimo commit
if [[ "${#ALL_TAGS_LINES[@]}" -eq 0 ]]; then
  FIRST_SHA="$(git -C "${REPO_PATH}" rev-list --max-parents=0 HEAD | tail -n1)"
  LAST_SHA="$(git -C "${REPO_PATH}" rev-parse HEAD)"
  CONF_PATH="conf/${PROJECT_NAME}.conf"
  {
    echo "# -*- yaml -*-"
    echo "# Autogenerated by generate_conf_from_repo.sh"
    echo "---"
    echo "project: ${PROJECT_NAME}"
    echo "repo: ${REPO_NAME}  # Relative to git-dir passed on CLI"
    echo "description: ${DESCRIPTION}"
    echo "revisions: [ \"${FIRST_SHA}\", \"${LAST_SHA}\" ]"
    echo "rcs: [ \"\", \"\" ]"
    echo "tagging: proximity"
    echo "sloccount: true"
  } > "${CONF_PATH}.tmp"
  command -v dos2unix >/dev/null 2>&1 && dos2unix -q "${CONF_PATH}.tmp" || true
  mv -f "${CONF_PATH}.tmp" "${CONF_PATH}"
  echo "✔ Config (fallback) generata: ${CONF_PATH}"
  exit 0
fi

# --- Separazione stable vs RC ---
# Consideriamo "RC" quelli che contengono rc/RC e varianti comuni
is_rc() {
  local t="${1}"
  [[ "${t}" =~ (^|[^a-zA-Z])([Rr][Cc])[0-9]*([^a-zA-Z]|$) ]] || [[ "${t}" =~ (-|_|\.)([Rr][Cc])[0-9]*$ ]]
}

# Normalizza “base” di confronto (toglie suffissi tipo -rc1, _RC2 ecc.)
base_of() {
  local t="${1}"
  # rimuove separatore + rc + numeri alla fine (es. -rc1, _RC2, .rc3)
  echo "${t}" | sed -E 's#([._-]?[Rr][Cc][0-9]*)$##'
}

# Varianti di confronto: sostituisce tra ., _, - per allineare stili
variants_of() {
  local s="${1}"
  # Produciamo alcune varianti plausibili
  echo "${s}"
  echo "${s//./_}"
  echo "${s//./-}"
  echo "${s//_/.}"
  echo "${s//_/-}"
  echo "${s//-/.}"
  echo "${s//-/_}"
}

# Parse all tags to arrays
STABLE_NAMES=()
STABLE_DATES=()
RC_NAMES=()
RC_DATES=()

for line in "${ALL_TAGS_LINES[@]}"; do
  name="${line%%|*}"
  date="${line#*|}"
  if is_rc "${name}"; then
    RC_NAMES+=("${name}")
    RC_DATES+=("${date}")
  else
    STABLE_NAMES+=("${name}")
    STABLE_DATES+=("${date}")
  fi
done

# Prendi solo gli ultimi N rilasci stabili (se ce ne sono tanti)
if (( ${#STABLE_NAMES[@]} > N_RELEASES )); then
  start=$(( ${#STABLE_NAMES[@]} - N_RELEASES ))
  STABLE_NAMES=("${STABLE_NAMES[@]:${start}}")
  STABLE_DATES=("${STABLE_DATES[@]:${start}}")
fi

# Se ci sono meno di 2 stable tags, fallback a primo/ultimo commit
if (( ${#STABLE_NAMES[@]} < 2 )); then
  FIRST_SHA="$(git -C "${REPO_PATH}" rev-list --max-parents=0 HEAD | tail -n1)"
  LAST_SHA="$(git -C "${REPO_PATH}" rev-parse HEAD)"
  STABLE_NAMES=("${FIRST_SHA}" "${LAST_SHA}")
  STABLE_DATES=("1970-01-01 00:00:00 +0000" "1970-01-02 00:00:00 +0000")
fi

# --- Mappatura RC -> Revisione ---
# Per ogni stable, prova:
#   1) match “nome” (base uguale, con varianti di separatori)
#   2) match “per data” (RC più vicina PRIMA della release)
map_rc_for_stable() {
  local stable_name="${1}"
  local stable_date="${2}"

  local base; base="$(base_of "${stable_name}")"

  # 1) Name-based
  mapfile -t base_variants < <(variants_of "${base}")
  for (( r=0; r<${#RC_NAMES[@]}; r++ )); do
    local rc="${RC_NAMES[$r]}"
    for bv in "${base_variants[@]}"; do
      # rc che "iniziano" con la base (nelle varianti)
      if [[ "${rc}" == "${bv}"* ]]; then
        echo "${rc}"
        return 0
      fi
    done
  done

  # 2) Date-based (scegli la RC più vicina e <= stable_date)
  # Confronto stringhe ISO8601: usare sort -r e pick la prima <=
  local best_rc=""
  local best_delta=""

  for (( r=0; r<${#RC_NAMES[@]}; r++ )); do
    local rc="${RC_NAMES[$r]}"
    local rdate="${RC_DATES[$r]}"

    # Se la RC è dopo la release, scarta
    # Convertiamo in epoch per robustezza
    local sd_epoch rd_epoch
    sd_epoch="$(date -d "${stable_date}" +%s 2>/dev/null || echo 0)"
    rd_epoch="$(date -d "${rdate}" +%s 2>/dev/null || echo 0)"
    if (( rd_epoch == 0 || sd_epoch == 0 )); then
      continue
    fi
    if (( rd_epoch <= sd_epoch )); then
      local delta=$(( sd_epoch - rd_epoch ))
      if [[ -z "${best_delta}" || ${delta} -lt ${best_delta} ]]; then
        best_delta="${delta}"
        best_rc="${rc}"
      fi
    fi
  done

  if [[ -n "${best_rc}" ]]; then
    echo "${best_rc}"
    return 0
  fi

  # Nessuna RC trovata
  echo ""
  return 0
}

# Costruisci la lista RCS (parallela alle STABLE_NAMES)
MAPPED_RCS=()
for (( i=0; i<${#STABLE_NAMES[@]}; i++ )); do
  MAPPED_RCS+=( "$(map_rc_for_stable "${STABLE_NAMES[$i]}" "${STABLE_DATES[$i]}")" )
done

# --- Scrivi YAML ---
CONF_PATH="conf/${PROJECT_NAME}.conf"
{
  echo "# -*- yaml -*-"
  echo "# Autogenerated by generate_conf_from_repo.sh"
  echo "---"
  echo "project: ${PROJECT_NAME}"
  echo "repo: ${REPO_NAME}  # Relative to git-dir passed on CLI"
  echo "description: ${DESCRIPTION}"

  # revisions
  echo -n "revisions: [ "
  for i in "${!STABLE_NAMES[@]}"; do
    printf '"%s"' "${STABLE_NAMES[$i]}"
    if [[ $i -lt $((${#STABLE_NAMES[@]} - 1)) ]]; then printf ", "; fi
  done
  echo " ]"

  # rcs (stessa lunghezza; "" se mancante)
  echo -n "rcs: [ "
  for i in "${!MAPPED_RCS[@]}"; do
    if [[ -n "${MAPPED_RCS[$i]}" ]]; then
      printf '"%s"' "${MAPPED_RCS[$i]}"
    else
      printf '""'
    fi
    if [[ $i -lt $((${#MAPPED_RCS[@]} - 1)) ]]; then printf ", "; fi
  done
  echo " ]"

  echo "tagging: proximity"
  echo "sloccount: true"
} > "${CONF_PATH}.tmp"

# Normalizza a LF se disponibile
command -v dos2unix >/dev/null 2>&1 && dos2unix -q "${CONF_PATH}.tmp" || true
mv -f "${CONF_PATH}.tmp" "${CONF_PATH}"

echo "✔ Config generata: ${CONF_PATH}"
echo
echo "— Anteprima —"
echo "----------------------------------------"
sed -n '1,120p' "${CONF_PATH}"
echo "----------------------------------------"
echo
echo "Per analizzare:"
echo "  codeface -j8 run -c codeface.conf -p ${CONF_PATH} results/ git-repos/"
